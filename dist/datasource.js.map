{"version":3,"sources":["../src/datasource.js"],"names":["_","TsvDatasource","instanceSettings","$q","backendSrv","templateSrv","type","url","name","q","queryOptions","self","from","Date","range","valueOf","getTime","to","target","targets","reqOpts","method","datasourceRequest","then","result","data","rawDatapoints","tsvParse","timeCol","timecol","valueCol","valuecol","console","log","hasheadings","indexOf","shift","datapoints","counter","j","length","isNaN","parseInt","time","value","sort","a","b","tsv","lines","split","i","currentline","push"],"mappings":"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","file":"datasource.js","sourcesContent":["import _ from \"lodash\";\n\nexport class TsvDatasource {\n\n  constructor(instanceSettings, $q, backendSrv, templateSrv) {\n    this.type = instanceSettings.type;\n    this.url = instanceSettings.url;\n    this.name = instanceSettings.name;\n    this.q = $q;\n    this.backendSrv = backendSrv;\n    this.templateSrv = templateSrv;\n  }\n\n  // Query for metric targets within the specified time range.\n  // Returns the promise of a result dictionary. See the convertResponse comment\n  // for specifics of the result dictionary.\n  query(queryOptions) {\n    var self = this;\n\n    var from = new Date( queryOptions.range.from.valueOf() ).getTime();\n    var to = new Date( queryOptions.range.to.valueOf() ).getTime();\n\n    var target = queryOptions.targets[ 0 ];\n\n    var reqOpts = {\n      method: 'GET',\n      url: target.url || ''\n    };\n\n    return this.backendSrv.datasourceRequest( reqOpts ).then( function( result ) {\n\n      //Return empty if empty...\n      if( !result || !result.data ) {\n        return [];\n      }\n\n      //Parse the TSV...\n      var rawDatapoints = self.tsvParse( result.data );\n\n      //If there are headings, get the index of the col we mean\n      var timeCol = target.timecol;\n      var valueCol = target.valuecol;\n\n      console.log('time and value col');\n      console.log(timeCol);\n      console.log(valueCol);\n\n      if( target.hasheadings ) {\n        console.log(\"hasheadings true\");\n        //TODO if has headings we could only look for the index if a string is actually provided\n        timeCol = rawDatapoints[ 0 ].indexOf( timeCol );\n        valueCol = rawDatapoints[ 0 ].indexOf( valueCol );\n        // Remove the headings\n        rawDatapoints.shift();\n      }\n\n      console.log('time and value col');\n      console.log(timeCol);\n      console.log(valueCol);\n\n      console.log( 'rawdatapoints' );\n      console.log( rawDatapoints );\n\n      //Refine to only the cold we need...\n      //And try to fix dates!\n      var datapoints = [];\n      var counter = 0;\n      for( var j = 0; j < rawDatapoints.length; j++ ) {\n        if (!isNaN(rawDatapoints[j][timeCol])) {\n          rawDatapoints[j][timeCol] = parseInt(rawDatapoints[j][timeCol], 10);\n        }\n        var time = new Date( rawDatapoints[j][timeCol] ).getTime();\n        var value = rawDatapoints[j][valueCol];\n        //Only add them if valid :/\n        if( time && value ) {\n          //Only return things in the time range!\n          if( time > from && time < to ) {\n            datapoints[ counter ] = [ value, time ];\n            counter++;\n          }\n        } else {\n          console.log( \"Error in TSV data? \" + j + ', ' + time + ', ' + value );\n        }\n      }\n\n      //Got to sort the order so the lines etc looks right\n      datapoints.sort( function(a,b){ return a[1] - b[1] } )\n\n      console.log( 'datapoints' );\n      console.log( datapoints );\n\n      //Return in the format expected\n      return { data: [ { datapoints: datapoints, target: target.name } ] };\n    } );\n  };\n\n  /**\n   * Could easily be modified for CSVs\n   * @param tsv\n   * @returns {Array}\n   */\n  tsvParse(tsv) {\n    var lines = tsv.split( \"\\n\" );\n    var result = [];\n\n    for( var i = 0; i < lines.length; i++ ) {\n      var currentline = lines[ i ].split( \"\\t\" );\n      result.push( currentline );\n    }\n\n    return result;\n  };\n}\n"]}